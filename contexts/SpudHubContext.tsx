import React, { useState, useEffect, useCallback, createContext, useContext, useMemo } from 'react';
import { useToast } from './ToastContext.tsx';
import useStickyState from '../hooks/useStickyState.ts';
import { defaultData } from '../constants.ts';
import { SpudHubData, Evidence, ActionItem, WellnessLog, AccountabilityEntry, StrategyGoal, NdisActivity, PromptSettings, CaseData, NdisData, FamilyData, StrategyArgument, Mission, Child, MissionStep, MissionSubTask, WellnessLinkContext, Theme, NexusGraphData, EvidenceEntities, PersonalVaultEntry, Campaign, ChildAdvocacyItem, GratitudeEntry, NexusNode, NexusLink } from '../services/types.ts';
import { generateMissionPlan, analyzeFailureImpact, extractEntitiesAndTags, generateAdvocacyPlan } from '../services/geminiService.ts';


const SpudHubContext = createContext(undefined);

export function SpudHubProvider({ children }) {
    const { addToast } = useToast();
    const [isDataLoading, setIsDataLoading] = useState(true);
    
    const [allData, setAllData] = useStickyState<SpudHubData>(defaultData, 'spudHubData');
    
    const [activeTab, setActiveTab] = useState('War Room');
    const [actionToExecute, setActionToExecute] = useState(null);
    const [highlightedArgument, setHighlightedArgument] = useState(null);
    const [missionGenState, setMissionGenState] = useState({ isLoading: false, objective: '' });

    // Initial load toast
    useEffect(() => {
        addToast("Spud Hub OS: Citadel of Flames Edition is online.", "info");
        setIsDataLoading(false);
    }, [addToast]);
    
    // Generic updater
    const updateData = useCallback(<K extends keyof SpudHubData>(key: K, value: SpudHubData[K]) => {
        setAllData(prev => ({ ...prev, [key]: value }));
    }, [setAllData]);

    const hideCommandDeck = useCallback(() => {
        setAllData(prev => ({...prev, showCommandDeck: false}));
    }, [setAllData]);
    
    const markRevealAsShown = useCallback(() => {
        setAllData(prev => ({...prev, revealShown: true}));
    }, [setAllData]);

    const updateTheme = useCallback((theme: Theme) => {
        setAllData(prev => ({...prev, activeTheme: theme}));
    }, [setAllData]);

    const addEvidence = useCallback(async (fileName: string, description: string, date: string, userTags: string[] = []) => {
        const newEvidence: Evidence = {
            id: Date.now(),
            fileName,
            description,
            date,
            tags: userTags,
            entities: { dates: [], names: [], refs: [], orgs: [] }
        };

        // Add to state immediately for responsiveness
        setAllData(prev => ({
            ...prev,
            evidenceData: [newEvidence, ...prev.evidenceData].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
        }));
        addToast("Evidence record added.", "success");

        // Enhance with AI in the background if API key is available
        if (allData.geminiApiKey) {
            try {
                const { entities, tags: aiTags } = await extractEntitiesAndTags(allData.geminiApiKey, description, allData.promptSettings.extractEntitiesAndTags);
                const combinedTags = [...new Set([...userTags, ...aiTags])];
                
                const enhancedEvidence: Evidence = {
                    ...newEvidence,
                    entities,
                    tags: combinedTags,
                };

                // Update the record in state with the new AI-generated data
                setAllData(prev => ({
                    ...prev,
                    evidenceData: prev.evidenceData.map(e => e.id === newEvidence.id ? enhancedEvidence : e)
                }));
                addToast("AI entity and tag extraction complete.", "info");
            } catch (e) {
                const error = e instanceof Error ? e : new Error(String(e));
                addToast(`AI Analysis Failed: ${error.message}`, "error");
            }
        }
        
        return newEvidence;
    }, [addToast, setAllData, allData.geminiApiKey, allData.promptSettings.extractEntitiesAndTags]);


    const updateEvidence = useCallback((updatedEvidence: Evidence) => {
        setAllData(prev => ({
            ...prev,
            evidenceData: prev.evidenceData.map(e => e.id === updatedEvidence.id ? updatedEvidence : e)
                .sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime())
        }));
        addToast("Evidence record updated.", "success");
    }, [addToast, setAllData]);

    const addActionItem = useCallback((item: Partial<ActionItem>) => {
        const newActionItem: ActionItem = { id: Date.now(), status: 'Draft', notes: `Generated by SpudBud on ${new Date().toLocaleDateString()}.`, ...item } as ActionItem;
        updateData('actionItems', [newActionItem, ...allData.actionItems]);
        setActiveTab('Action Tracker');
        addToast("New action item created.", "success");
    }, [addToast, allData.actionItems, updateData, setActiveTab]);

    const addWellnessLog = useCallback((log: Omit<WellnessLog, 'id' | 'date'>) => {
        const newLog: WellnessLog = { id: Date.now(), date: new Date().toISOString(), ...log };
        updateData('wellnessLogs', [newLog, ...allData.wellnessLogs].sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime()));
        addToast("Daily check-in logged.", "success");
    }, [addToast, allData.wellnessLogs, updateData]);

    const updateActionItem = useCallback((id: number, field: keyof ActionItem, value: any) => {
        updateData('actionItems', allData.actionItems.map(action => action.id === id ? { ...action, [field]: value } : action));
    }, [allData.actionItems, updateData]);

    const updateStrategy = useCallback((newStrategy: StrategyGoal[]) => {
        updateData('strategyData', newStrategy);
    }, [updateData]);
    
    const updateChild = useCallback((updatedChild: Child) => {
        setAllData(prev => ({
            ...prev,
            familyData: {
                ...prev.familyData,
                children: prev.familyData.children.map(c => c.id === updatedChild.id ? updatedChild : c)
            }
        }));
        addToast(`${updatedChild.name}'s record updated.`, "success");
    }, [setAllData, addToast]);
    
    const generateChildAdvocacyPlan = useCallback(async (childId: number) => {
        const child = allData.familyData.children.find(c => c.id === childId);
        if (!child || !allData.geminiApiKey) {
            addToast("Cannot generate plan. API key may be missing.", "error");
            return;
        }
        
        try {
            const { plan } = await generateAdvocacyPlan(allData.geminiApiKey, child, allData.promptSettings.generateAdvocacyPlan);
            const newAdvocacyItems: ChildAdvocacyItem[] = plan.map(goal => ({
                id: Date.now() + Math.random(),
                goal,
                status: 'active',
                actions: []
            }));

            const updatedChild = { ...child, advocacyPlan: newAdvocacyItems };
            updateChild(updatedChild);
            addToast(`Advocacy plan generated for ${child.name}.`, "success");
        } catch (e) {
            const error = e instanceof Error ? e : new Error(String(e));
            addToast(`Plan Generation Failed: ${error.message}`, "error");
            throw e;
        }
    }, [allData.familyData.children, allData.geminiApiKey, allData.promptSettings.generateAdvocacyPlan, updateChild, addToast]);

    const addStrategicGoal = useCallback((goalText: string) => {
        const newGoal: StrategyGoal = { id: Date.now(), text: goalText, arguments: [] };
        updateData('strategyData', [...allData.strategyData, newGoal]);
        addToast("New strategic goal added.", "success");
    }, [addToast, allData.strategyData, updateData]);

    const addNdisActivity = useCallback((task: string, time: string) => {
        const newActivity: NdisActivity = { id: Date.now(), date: new Date().toISOString(), task, time: parseFloat(time) };
        setAllData(prev => ({...prev, ndisData: {...prev.ndisData, activities: [newActivity, ...prev.ndisData.activities]}}));
        addToast("NDIS activity logged.", "success");
    }, [addToast, setAllData]);

    const addAccountabilityEntry = useCallback((entry: Omit<AccountabilityEntry, 'id'>) => {
        const newEntry: AccountabilityEntry = { id: Date.now(), status: 'Logged', ...entry };
        updateData('accountabilityEntries', [newEntry, ...allData.accountabilityEntries].sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime()));
        addToast("Charge added to the Accountability Citadel.", "success");
    }, [addToast, allData.accountabilityEntries, updateData]);
    
    const updateAccountabilityEntryStatus = useCallback((id: number, status: AccountabilityEntry['status']) => {
        setAllData(prev => ({
            ...prev,
            accountabilityEntries: prev.accountabilityEntries.map(e => e.id === id ? { ...e, status } : e)
        }));
    }, [setAllData]);
    
    const analyzeImpactForCharge = useCallback(async (entryId: number) => {
        const entry = allData.accountabilityEntries.find(e => e.id === entryId);
        if (!entry) return;
        
        try {
            const analysis = await analyzeFailureImpact(allData.geminiApiKey, entry, allData.promptSettings.analyzeFailureImpact);
            setAllData(prev => ({
                ...prev,
                accountabilityEntries: prev.accountabilityEntries.map(e => e.id === entryId ? { ...e, impactAnalysis: analysis } : e)
            }));
            addToast("Impact analysis complete.", "success");
        } catch (e) {
            const error = e instanceof Error ? e : new Error(String(e));
            addToast(`Analysis failed: ${error.message}`, "error");
            throw e; // re-throw for the component to handle loading state
        }
    }, [allData.accountabilityEntries, allData.geminiApiKey, allData.promptSettings.analyzeFailureImpact, setAllData, addToast]);


    const updatePromptSetting = useCallback((key: string, value: string) => {
        setAllData(prev => ({...prev, promptSettings: {...prev.promptSettings, [key]: value}}));
    }, [setAllData]);

    const updateApiKey = useCallback((key: string) => {
        setAllData(prev => ({...prev, geminiApiKey: key}));
        addToast("API Key updated.", "success");
    }, [addToast, setAllData]);

    const createMission = useCallback(async (objective: string, campaignId?: number) => {
        setMissionGenState({ isLoading: true, objective });
        setActiveTab('Missions');
        try {
            const { promptSettings, missions, geminiApiKey, ...snapshot } = allData;
            const newMissionPlan = await generateMissionPlan(geminiApiKey, objective, snapshot, promptSettings.generateMissionPlan);
            const newMission: Mission = {
                id: Date.now(),
                ...newMissionPlan,
                status: 'suggested',
                campaignId: campaignId
            };
            updateData('missions', [newMission, ...allData.missions]);
            addToast(`New Mission "${newMission.title}" has been generated!`, "success");
        } catch (e) {
            const error = e instanceof Error ? e : new Error(String(e));
            addToast(`Mission generation failed: ${error.message}`, 'error');
        } finally {
            setMissionGenState({ isLoading: false, objective: '' });
        }
    }, [allData, addToast, updateData, setActiveTab]);
    
    const executeAction = useCallback((action) => {
        setActionToExecute(action);
        setActiveTab('Advocacy Assistant');
        addToast("Advocacy Assistant prepped for action!", "info");
    }, [setActiveTab, addToast]);

    const clearAction = useCallback(() => setActionToExecute(null), []);
    const clearHighlights = useCallback(() => setHighlightedArgument(null), []);

    const executeInsightAction = useCallback((action) => {
        switch (action.type) {
            case 'NAVIGATE': setActiveTab(action.payload.tab); break;
            case 'PRIME_ADVOCACY': executeAction(action.payload); break;
            case 'HIGHLIGHT_STRATEGY': setActiveTab('Case Strategy'); setTimeout(() => setHighlightedArgument(action.payload.argumentId), 50); break;
            case 'CREATE_MISSION': createMission(action.payload.objective); break;
        }
    }, [setActiveTab, executeAction, createMission]);

    const handleExportData = useCallback(() => {
        const dataStr = JSON.stringify(allData, null, 2);
        const dataBlob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `spud-hub-os-backup-${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        addToast("Local data backup downloaded.", "success");
    }, [allData, addToast]);

    const handleImportData = useCallback((file: File) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            if (e.target?.result) {
                try {
                    const fileContent = e.target.result;
                    if (typeof fileContent !== 'string') throw new Error("Backup file could not be read as text.");
                    const importedData = JSON.parse(fileContent);
                    if ('promptSettings' in importedData && 'caseData' in importedData) {
                        const validatedData = { ...defaultData, ...importedData };
                        setAllData(validatedData);
                        addToast("Data restored from backup file!", "success");
                    } else {
                        addToast("Error: Invalid backup file format.", "error");
                    }
                } catch (err) {
                    const error = err instanceof Error ? err : new Error(String(err));
                    console.error("Failed to parse or load backup file:", error);
                    addToast(`Error: Could not load backup. ${error.message}`, "error");
                }
            }
        };
        reader.readAsText(file);
    }, [addToast, setAllData]);

    const handleResetData = useCallback(() => {
        if (window.confirm("Are you absolutely sure you want to reset ALL application data? This action cannot be undone and will erase everything from this browser.")) {
            localStorage.removeItem('spudHubData');
            window.location.reload();
        }
    }, []);
    
    const addCampaign = useCallback((title: string, objective: string) => {
        const newCampaign: Campaign = {
            id: Date.now(),
            title,
            objective,
            status: 'active',
        };
        setAllData(prev => ({ ...prev, campaigns: [...prev.campaigns, newCampaign] }));
        addToast(`New campaign '${title}' created.`, 'success');
        return newCampaign;
    }, [setAllData, addToast]);

    const updateMissionStep = useCallback((missionId, stepId, updatedStepData) => {
        setAllData(prev => ({
            ...prev,
            missions: prev.missions.map(m => {
                if (m.id === missionId) {
                    const updatedSteps = m.steps.map(s => s.id === stepId ? { ...s, ...updatedStepData } : s);
                    const allComplete = updatedSteps.every(s => s.status === 'complete');
                    
                    let newStatus: Mission['status'] = m.status;
                    if (allComplete) {
                        newStatus = 'complete';
                    } else if (m.status === 'complete') {
                        // If it was complete, but now isn't, it becomes active again.
                        newStatus = 'active';
                    }
                    
                    return { ...m, steps: updatedSteps, status: newStatus };
                }
                return m;
            })
        }));
    }, [setAllData]);
    

    const startMission = useCallback((missionId: number) => {
        setAllData(prev => ({
            ...prev,
            missions: prev.missions.map(m => m.id === missionId ? { ...m, status: 'active' } : m)
        }));
        addToast("Mission activated!", "info");
    }, [setAllData, addToast]);

    const nexusGraphData = useMemo<NexusGraphData>(() => {
        const nodes: NexusNode[] = [];
        const links: NexusLink[] = [];

        // Add Evidence Nodes
        allData.evidenceData.forEach(e => nodes.push({ id: `evidence-${e.id}`, label: e.fileName, type: 'Evidence', originalId: e.id }));
        
        // Add Goal and Argument Nodes, and link arguments to goals
        allData.strategyData.forEach(goal => {
            nodes.push({ id: `goal-${goal.id}`, label: `Goal: ${goal.text.substring(0, 30)}...`, type: 'Goal', originalId: goal.id });
            goal.arguments.forEach(a => {
                nodes.push({ id: `argument-${a.id}`, label: a.text, type: 'Argument', originalId: a.id });
                links.push({ source: `goal-${goal.id}`, target: `argument-${a.id}` });
                // Link arguments to evidence
                a.evidenceIds.forEach(eid => links.push({ source: `argument-${a.id}`, target: `evidence-${eid}` }));
            });
        });

        // Add Charge Nodes and link to evidence
        allData.accountabilityEntries.forEach(c => {
            nodes.push({ id: `charge-${c.id}`, label: `${c.agency}: ${c.failure.substring(0, 30)}...`, type: 'Charge', originalId: c.id });
            if (c.evidenceId) {
                links.push({ source: `charge-${c.id}`, target: `evidence-${c.evidenceId}` });
            }
        });
        
        // Add Mission Nodes
        allData.missions.filter(m => m.status === 'active').forEach(m => nodes.push({ id: `mission-${m.id}`, label: `Mission: ${m.title}`, type: 'Mission', originalId: m.id }));

        return { nodes, links };
    }, [allData.evidenceData, allData.strategyData, allData.accountabilityEntries, allData.missions]);

    // Personal Vault Functions
    const addPersonalVaultEntry = useCallback((title: string, content: string) => {
        const newEntry: PersonalVaultEntry = {
            id: Date.now(),
            date: new Date().toISOString(),
            title,
            content
        };
        setAllData(prev => ({ ...prev, personalVaultData: [newEntry, ...prev.personalVaultData].sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime()) }));
        addToast("Vault entry saved.", "success");
        return newEntry.id;
    }, [setAllData, addToast]);

    const updatePersonalVaultEntry = useCallback((id: number, title: string, content: string) => {
        setAllData(prev => ({
            ...prev,
            personalVaultData: prev.personalVaultData.map(entry =>
                entry.id === id ? { ...entry, title, content, date: new Date().toISOString() } : entry
            )
        }));
        addToast("Vault entry updated.", "info");
    }, [setAllData, addToast]);

    const deletePersonalVaultEntry = useCallback((id: number) => {
        if (window.confirm("Are you sure you want to permanently delete this vault entry?")) {
            setAllData(prev => ({ ...prev, personalVaultData: prev.personalVaultData.filter(entry => entry.id !== id) }));
            addToast("Vault entry deleted.", "success");
        }
    }, [setAllData, addToast]);

    // Gratitude Journal Functions
    const addGratitudeEntry = useCallback((supporterId: number, title: string, content: string) => {
        const newEntry: GratitudeEntry = {
            id: Date.now(),
            supporterId,
            date: new Date().toISOString(),
            title,
            content
        };
        setAllData(prev => ({
            ...prev,
            familyData: {
                ...prev.familyData,
                gratitudeJournal: [newEntry, ...prev.familyData.gratitudeJournal].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
            }
        }));
        addToast("Gratitude entry saved.", "success");
        return newEntry;
    }, [setAllData, addToast]);

    const updateGratitudeEntry = useCallback((entryId: number, title: string, content: string) => {
        setAllData(prev => ({
            ...prev,
            familyData: {
                ...prev.familyData,
                gratitudeJournal: prev.familyData.gratitudeJournal.map(entry =>
                    entry.id === entryId ? { ...entry, title, content, date: new Date().toISOString() } : entry
                )
            }
        }));
        addToast("Gratitude entry updated.", "info");
    }, [setAllData, addToast]);

    const deleteGratitudeEntry = useCallback((entryId: number) => {
        if (window.confirm("Are you sure you want to delete this gratitude entry?")) {
            setAllData(prev => ({
                ...prev,
                familyData: {
                    ...prev.familyData,
                    gratitudeJournal: prev.familyData.gratitudeJournal.filter(entry => entry.id !== entryId)
                }
            }));
            addToast("Gratitude entry deleted.", "success");
        }
    }, [setAllData, addToast]);

    const contextValue = useMemo(() => ({
        activeTab, setActiveTab,
        ...allData,
        hideCommandDeck,
        markRevealAsShown,
        updateTheme,
        addEvidence, updateEvidence, addNdisActivity, addActionItem, addWellnessLog, addAccountabilityEntry, updateAccountabilityEntryStatus, analyzeImpactForCharge,
        updateActionItem, updateStrategy, addStrategicGoal, updatePromptSetting, updateApiKey, updateChild, generateChildAdvocacyPlan,
        handleExportData, handleImportData, handleResetData,
        executeAction, clearAction, actionToExecute,
        executeInsightAction, highlightedArgument, clearHighlights,
        isDataLoading, createMission, missionGenState,
        updateMissionStep, startMission, addCampaign,
        nexusGraphData,
        addPersonalVaultEntry, updatePersonalVaultEntry, deletePersonalVaultEntry,
        addGratitudeEntry, updateGratitudeEntry, deleteGratitudeEntry
    }), [activeTab, allData, hideCommandDeck, markRevealAsShown, updateTheme, addEvidence, updateEvidence, addNdisActivity, addActionItem, addWellnessLog, addAccountabilityEntry, updateAccountabilityEntryStatus, analyzeImpactForCharge, updateActionItem, updateStrategy, addStrategicGoal, updatePromptSetting, updateApiKey, updateChild, generateChildAdvocacyPlan, handleExportData, handleImportData, handleResetData, executeAction, clearAction, actionToExecute, executeInsightAction, highlightedArgument, clearHighlights, isDataLoading, createMission, missionGenState, updateMissionStep, startMission, addCampaign, nexusGraphData, addPersonalVaultEntry, updatePersonalVaultEntry, deletePersonalVaultEntry, addGratitudeEntry, updateGratitudeEntry, deleteGratitudeEntry]);

    return React.createElement(SpudHubContext.Provider, { value: contextValue }, children);
}

export function useSpudHub() {
    const context = useContext(SpudHubContext);
    if (context === undefined) {
        throw new Error('useSpudHub must be used within a SpudHubProvider');
    }
    return context;
}
